#version 430

// размеры volume (передать uniform)
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

uniform ivec3 uVolumeSize;   // размер (width, height, depth)
uniform float uDecay;       // сколько отнимается за шаг (пример 1.0)
uniform int uMaxIter;       // макс итераций (обычно 8-32)
uniform int uPass;          // текущая итерация (если делаем многопроходно)

// binding 0 = текущий volume (read), binding 1 = новый volume (write)
layout(rgba16f, binding = 0) uniform image3D imgVolumeRead;
layout(rgba16f, binding = 1) uniform image3D imgVolumeWrite;

// helper: sample voxel safely
vec4 readVoxel(ivec3 p) {
    // clamp or discard outside
    if(any(lessThan(p, ivec3(0))) || any(greaterThanEqual(p, uVolumeSize))) return vec4(0.0);
    return imageLoad(imgVolumeRead, p);
}

void main() {
    ivec3 gid = ivec3(gl_GlobalInvocationID);
    if(any(greaterThanEqual(gid, uVolumeSize))) return;

    // current value
    vec4 cur = readVoxel(gid); // rgb=color*intensity, a = level (used for quick compare)

    // gather neighbors
    float bestLevel = cur.a;
    vec3 bestColor = cur.rgb;

    // 6 neighbors
    ivec3 dirs[6] = ivec3[6](
        ivec3(1,0,0), ivec3(-1,0,0),
        ivec3(0,1,0), ivec3(0,-1,0),
        ivec3(0,0,1), ivec3(0,0,-1)
    );

    for(int i=0;i<6;i++){
        ivec3 np = gid + dirs[i];
        vec4 nval = readVoxel(np);
        if(nval.a <= 0.0) continue;
        // decay: neighbor level - decay
        float candidate = nval.a - uDecay;
        if(candidate > bestLevel) {
            bestLevel = candidate;
            // preserve color proportionally: color * (candidate / nval.a)
            // but simpler: mix by candidate
            if(nval.a > 0.0)
                bestColor = nval.rgb * (candidate / max(0.0001, nval.a));
            else
                bestColor = nval.rgb;
        }
    }

    // If current is an emitter with high level, we should not decay it: assume CPU set initial emitters into imgVolumeRead before the propagation loop.
    // write back
    vec4 outv = vec4(bestColor, max(0.0, bestLevel));
    imageStore(imgVolumeWrite, gid, outv);
}
